<!DOCTYPE html>
<html>

<head>
	<title>星戟数据中心3D演示</title>
	<meta charset="utf-8" />

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="css/main.css">
</head>

<body>



	<div id="root-div">
		<div id="progress" class="progress">
			<div class="mask"></div>
			<div class="loading">
				<div class="trends"></div>
			</div>
		</div>

		<h4 class="title-div">星戟数据中心3D演示</h4>

		<p class="content-div">
			适用于金融、电信、政府、军队、传统大中型IDC、边缘IDC以及大中企业等各种数据中心
		</p>

		

		<div id="container" class="container"></div>

	</div>


	<!-- 	定义浏览器中的全局模块	 -->
	<script type="importmap">
			{
				"imports": {
					"three": "./js/libs/three/three.module.js"
				}
			}
		</script>
	<script type="module">// 添加 type="module" 允许执行导入导出操作 export import，缺省设置为Defer，延时执行
		// 自动加载 ./js/libs/three/three.module.js
		import * as THREE from 'three';
		// export import 引入模块
		import { MTLLoader } from './js/libs/three/loaders/MTLLoader.js';
		import { OBJLoader } from './js/libs/three/loaders/OBJLoader.js';
		import { OrbitControls } from '/js/libs/three/controls/OrbitControls.js';

		let camera, scene, renderer, controls;

		let mouseX = 0, mouseY = 0;

		let windowHalfX = window.innerWidth / 2;
		let windowHalfY = window.innerHeight / 2;

		// 3D 模型名与对应文件名一致
		let modelName = 'ruby_rose'
		let modelPath = `assets/models/${modelName}/`


		init();
		animate();


		function init() {

			const container = document.getElementById('container');
			// const container = document.createElement('div');
			// document.body.appendChild(container);
	
			/*  
				PerspectiveCamera
				
				视野角度,长宽比,近截面,远截面	
			*/
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.z = 250;



			// scene

			scene = new THREE.Scene();

			// 
			const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
			scene.add(ambientLight);

			const pointLight = new THREE.PointLight(0xffffff, 0.8);
			camera.add(pointLight);
			scene.add(camera);

			// model

			const onProgress = function (xhr) {

				if (xhr.lengthComputable) {

					const percentComplete = xhr.loaded / xhr.total * 100;
					let progress = Math.round(percentComplete, 2)
					console.log(progress + '% downloaded');
					showProgress(progress)
				}

			};

			new MTLLoader()
				.setPath(modelPath)
				.load(`${modelName}.mtl`, function (materials) {

					materials.preload();

					new OBJLoader()
						.setMaterials(materials)
						.setPath(modelPath)
						.load(`${modelName}.obj`, function (object) {

							// 模型缩放
							object.scale.set(15, 15, 15);
							// 改变模型的加载位置
							object.position.set(0, -50, 0);

							scene.add(object);

						}, onProgress);

				});

			// 渲染器设置alpha: true否则背景图不显示
			renderer = new THREE.WebGLRenderer({ alpha: true });
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			// 设置鼠标缩放，旋转效果
			controls = new OrbitControls(camera, renderer.domElement);
			controls.listenToKeyEvents(window);
			controls.enableDamping = true;// 启用阻尼或自动旋转时，需要在animate()中调用update()
			controls.enablePan = false;// 禁止右键拖拽
			controls.screenSpacePanning = false;// 屏幕空间平移
			// controls.autoRotate = true;// 启动自动旋转
			// 禁用垂直旋转
			controls.minPolarAngle = Math.PI / 2;
			controls.maxPolarAngle = Math.PI / 2;


			// 窗口改变监听	
			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onDocumentMouseMove(event) {

			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();

		}

		function render() {
			// required if controls.enableDamping or controls.autoRotate are set to true
			controls.update();
			renderer.render(scene, camera);

		}


		function showProgress(progress) {
			document.getElementsByClassName("trends")[0].style.width = progress + "%";
			if (progress < 100) {
				document.getElementById("progress").style.display = "block";
			} else {
				document.getElementById("progress").style.display = "none";
			}
		}



	</script>
</body>

</html>